using FlatRedBall.Content.AnimationChain;
using System.Collections.Generic;
using System;
using System.IO;
using System.Linq;

using System.Drawing; // WinForms
using System.Drawing.Imaging; // WinForms
using System.Windows.Media.Imaging; // WPF

using BlitBitmapNS;

// Debug
using RCommon;
using System.Diagnostics;


namespace AnimChainsGenerator
{
    public sealed class Generator
    {
        #region    --- GenerateFromParameters

        private static SizeUint _FrameSize;
        private static string _SpriteSheetFileName;
        private static ushort _Rotations;
        private static Offset<float> _AllFramesOffset;

        /// <summary>Generates AnimationChainListSave data structure based on input data.</summary>
        /// <param name="frameSize">Size of one sprite sheet cell. All cells in spritesheed have to have uniform size.</param>
        /// <param name="spriteSheetFileName">Only file name of sprite sheet that should be used for generated anim chain. Without path.</param>
        /// <param name="rotations">Number of rotations (sprite sheet rows) for graphic character/object this anim chain is generated for.</param>
        /// <param name="animsDefinitions">List of AnimDefs defining animations for graphic character/object.</param>
        /// <returns>Generated AnimationChainListSave data.</returns>
        public static AnimationChainListSave GenerateFromParameters(
            SizeUint frameSize,
            string spriteSheetFileName,
            ushort rotations,
            Offset<float> allFramesOffset,
            IEnumerable<AnimDef> animsDefinitions
        )
        {
            _FrameSize = frameSize;
            _SpriteSheetFileName = spriteSheetFileName;
            _Rotations = rotations;
            _AllFramesOffset = allFramesOffset;

            AnimationChainListSave animChainListSave = new AnimationChainListSave
            {
                CoordinateType = FlatRedBall.Graphics.TextureCoordinateType.Pixel,
                FileRelativeTextures = true,
                TimeMeasurementUnit = FlatRedBall.TimeMeasurementUnit.Second
            };

            foreach (var animDef in animsDefinitions)
            {
                animChainListSave.AnimationChains.AddRange(
                    _GenerateAnimChain(animDef)
                );
            }

            return animChainListSave;
        }

        private static AnimationChainSave[] _GenerateAnimChain(AnimDef animDef)
        {
            // * frame coordinates are in pixels. top-left = 0,0  bottom-right = +X +Y

            float xStart = animDef.CellXstartIndex * _FrameSize.Width;
            float yStart = animDef.CellYstartIndex * _FrameSize.Height;

            AnimationChainSave[] animsList = new AnimationChainSave[_Rotations];

            //float currentXStart;
            float currentYTop;
            float currentYBottom;
            float left;
            AnimationChainSave oneRotAnim;
            AnimationFrameSave frame;
            for (ushort iRotation = 0; iRotation < 16; iRotation++)
            {
                currentYTop = yStart + iRotation * _FrameSize.Height;
                currentYBottom = currentYTop + _FrameSize.Height;
                oneRotAnim = new AnimationChainSave(); // animDef.FramesPerRotation
                oneRotAnim.Name = animDef.AnimName + '_' + iRotation.ToString();

                for (ushort iFrame = 0; iFrame < animDef.FramesPerRotation; iFrame++)
                {
                    left = xStart + iFrame * _FrameSize.Width;

                    frame = new AnimationFrameSave // (_FramesTexture, 0)
                    {
                        TextureName = _SpriteSheetFileName,
                        TopCoordinate = currentYTop,
                        BottomCoordinate = currentYBottom,
                        LeftCoordinate = left,
                        RightCoordinate = left + _FrameSize.Width,
                        RelativeX = _AllFramesOffset.X,
                        RelativeY = _AllFramesOffset.Y,
                        FrameLength = 0.1f
                    };

                    //oneRotAnim.Add(frame);
                    oneRotAnim.Frames.Add(frame);
                }

                //animsList.Add(oneRotAnim);
                animsList[iRotation] = oneRotAnim;
            }

            return animsList;
        } 

        /// <summary>Saves generated AnimChainList to file and copies it's sprite sheet file to same director if necessary.</summary>
        /// <param name="animChainListSave">AnimationChainListSave data structure generated by GenerateAnimChain()</param>
        /// <param name="achxSavePath">Directory path to where achx file should be saved</param>
        /// <param name="achxFileName">Name of achx output file without extension</param>
        /// <param name="spriteSheetLocation">Directory where sprite sheet image for this cnim chain is located</param>
        public static void SaveAchx(AnimationChainListSave animChainListSave, string achxSavePath, string achxFileName, string spriteSheetLocation)
        {
            if ( ! File.Exists( Path.Combine(achxSavePath, _SpriteSheetFileName) ) )
            {
                File.Copy(
                    Path.Combine(spriteSheetLocation, _SpriteSheetFileName),
                    Path.Combine(achxSavePath, _SpriteSheetFileName)
                );
            }

            animChainListSave.Save( Path.Combine(achxSavePath, achxFileName + ".achx") );
        }

        #endregion --- GenerateFromParameters END



        #region    --- GenerateFromImgSequences

        /*
        enemy1_move_1.png

        enemy1  = name of achx - for possible achx splits later
                  optional token
                  but the separator must still be present !
        move    = Anim(Chain) name
        1       = frame index in Anim(Chain)

        result in achx:
        enemy1_move (anim)
            frame
        */

        public const char IMG_FILE_NAME_PARTS_SEPARATOR = '_';
        //private static readonly char[] NUM_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

        /*/// <summary></summary>
        /// <param name="imgsDirPath">Path to directory containing the input sprite images. All subdirs will be scanned for images too.</param>
        /// <param name="outputDirPath">Path to directory where result .achx and sprite sheet png will be saved.</param>
        /// <param name="resultSpriteSheetFileName">Name of created sprite sheet png file. Without extension.</param>
        /// <returns></returns>
        public static AnimationChainListSave GenerateFromImgSequences(string imgsDirPath, string outputDirPath, string resultSpriteSheetFileName)
        {
            if (string.IsNullOrWhiteSpace(imgsDirPath))
                throw new ArgumentException("Generator.GenerateFromImgSequences() imgsDirPath empty.", nameof(imgsDirPath));

            if (string.IsNullOrWhiteSpace(outputDirPath))
                throw new ArgumentException("Generator.GenerateFromImgSequences() outputDirPath empty.", nameof(outputDirPath));

            if (string.IsNullOrWhiteSpace(resultSpriteSheetFileName))
                throw new ArgumentException("Generator.GenerateFromImgSequences() resultSpriteSheetFileName empty.", nameof(resultSpriteSheetFileName));

            if (Path.
        }*/
        /// <summary>
        /// Finds all .png images in directory structure. 
        /// Creates one big sprite sheet image from them.
        /// Creates FRB AnimationChains data ('achx') for the sheet.
        /// </summary>
        /// <param name="imgsDirPath">Path to directory containing the input sprite images. All subdirs will be scanned for images too.</param>
        /// <returns></returns>
        public static void GenerateFromImgSequences(
            string imgsDirPath, string spriteSheetFileName,
            out AnimationChainListSave animList, out Bitmap spriteSheet,
            int maxSpriteSheetWidth = 4096)
        {
            Debug.WriteLine("* GenerateFromImgSequences()");

            FrameFileInfo[] framesData;
            var animGroups = _GetFrameFilesData(imgsDirPath, out framesData);

            /*Debug.WriteLine(
                "\n------- animGroups -------\n"
                +
                Diag.PrintCollectionToString(
                    animGroups, 
                    group => Diag.PrintCollection(group)
                )
            );*/

            Debug.WriteLine(
                "\n------- framesData -------\n"
                +
                Diag.PrintCollectionToString(framesData)
            );


            // -- Create SpriteSheet image

            SizeInt spriteSheetSize = _LayoutSprites(framesData, ref maxSpriteSheetWidth);

            Debug.WriteLine($"   _LayoutSprites() calculated spriteSheetSize: {spriteSheetSize.Width},{spriteSheetSize.Height}");

            Debug.WriteLine(
                "\n------- animGroups -------\n"
                +
                Diag.PrintCollectionToString(
                    animGroups,
                    group => Diag.PrintCollection(group)
                )
            );
            //animList = null;
            //spriteSheet = null;

            BlitBitmap spriteSheetBBmp = new BlitBitmap(spriteSheetSize.Width, spriteSheetSize.Height);

            animList = _DrawSpritesAndCreateAnimChainsList(animGroups, spriteSheetSize, spriteSheetFileName, spriteSheetBBmp);
            spriteSheetBBmp.Unlock();
            spriteSheet = spriteSheetBBmp.Bitmap;
            //spriteSheetBBmp.Dispose();
        }

        private static FrameFileInfo[][] _GetFrameFilesData(string imgsDirPath, out FrameFileInfo[] frameInfos)
        {
            if (string.IsNullOrWhiteSpace(imgsDirPath)) throw new ArgumentException("Generator.GenerateFromImgSequences(): imgsDirPath null or empty string.", nameof(imgsDirPath));

            DirectoryInfo rootDirI = new DirectoryInfo(imgsDirPath);

            if (!rootDirI.Exists) throw new DirectoryNotFoundException("Generator.GenerateFromImgSequences(): imgsDirPath path doesn't exist.");

            FileInfo[] imgFileIs = rootDirI.GetFiles("*.png", SearchOption.AllDirectories);

            frameInfos = new FrameFileInfo[imgFileIs.Length];
            for (int i = 0; i < frameInfos.Length; i++)
            {
                frameInfos[i] = _TokenizeFileName(imgFileIs[i]);
            }

            Array.Sort(frameInfos, (itemA, itemB) => itemA.FrameIndex.CompareTo(itemB.FrameIndex));

            var animGroups = frameInfos
                    //.OrderBy(frameInfo => frameInfo.FrameIndex)
                    .GroupBy(frameInfo => frameInfo.AnimNameUpper, StringComparer.Ordinal)
                    .OrderBy(group => group.Key)
                    .Select(group => group.ToArray())
                    .ToArray();

            frameInfos = animGroups.SelectMany(arr => arr).ToArray();

            foreach (var animGroup in animGroups)
            {
                foreach (var frameInfo in animGroup)
                {
                    frameInfo.PixelSize = _GetImageFilePixelSize(frameInfo.FileInfo);
                }
            }

            return animGroups;
        }

        private static FrameFileInfo _TokenizeFileName(FileInfo fileInfo)
        {
            // ** "__aaa_bbb".Split('_')     returns     { String.Empty, String.Empty, "aaa", "bbb" }

            string withoutExtension = fileInfo.Name.Substring(0, fileInfo.Name.Length - 4);

            string stringToken;
            int indexToken;

            if (!_TryCustomSplit(withoutExtension, out stringToken, out indexToken))
                throw new Exception($"Generator.GenerateFromImgSequences(): name of file \"{fileInfo.FullName}\" has wrong format.");

            FrameFileInfo fileTokens = new FrameFileInfo();

            fileTokens.FileInfo = fileInfo;
            fileTokens.FrameIndex = indexToken;
            fileTokens.AnimName = stringToken;
            fileTokens.AnimNameUpper = stringToken.ToUpper();

            return fileTokens;
        }
        public static bool _TryCustomSplit(string str, out string stringToken, out int indexToken)
        {
            stringToken = null;
            indexToken = -1;

            int separatorPos = str.IndexOf(IMG_FILE_NAME_PARTS_SEPARATOR);

            if (separatorPos == -1) // missing any token separators
                return false;

            // Found first separator = end of first token

            separatorPos = str.IndexOf(IMG_FILE_NAME_PARTS_SEPARATOR, separatorPos + 1);

            if (separatorPos == -1) // missing 3rd token
                return false;

            // Found second separator = end of second token

            //tokensList.Add( str.Substring(0, separatorPos) );
            stringToken = str.Substring(0, separatorPos);

            int i = separatorPos + 1;
            int charsFound = 0;
            for (; i < str.Length; i++)
            {
                if (!Char.IsNumber(str[i]))
                    break;
                else
                    charsFound++;
            }

            if (i == separatorPos + 1) // no numerical chars were found = no number token was found = frame index token not found
                return false;

            indexToken = Int32.Parse(str.Substring(separatorPos + 1, charsFound));

            return true;
        }

        private static SizeInt _GetImageFilePixelSize(FileInfo fileInfo)
        {
            SizeInt imagePixelSize = new SizeInt();
            System.Windows.Media.PixelFormat pixelFormat;

            //using(var imageStream = File.OpenRead(filePath))
            using (var imageStream = fileInfo.OpenRead())
            {
                var decoder = BitmapDecoder.Create(imageStream, BitmapCreateOptions.IgnoreColorProfile, BitmapCacheOption.None);
                var frame = decoder.Frames[0];

                pixelFormat = frame.Format;

                imagePixelSize.Height = frame.PixelWidth;
                imagePixelSize.Width = frame.PixelHeight;
            }

            if (pixelFormat.BitsPerPixel != 32)
                throw new NotSupportedException("Generator.GenerateFromImgSequences(): file \"{fileInfo.FullName}\" is in unsupported file format. Only 32bit ARGB images supported.");

            return imagePixelSize;
        }

        private static SizeInt _LayoutSprites(FrameFileInfo[] framesData, ref int maxSpriteSheetWidth)
        {
            SizeInt spriteSheetSize = new SizeInt();

            int lineWidth = 0;
            int lineHight = 0;

            int newLineWidth;

            // Make sure that all sprites can fit onto sheet (width)
            foreach (var frame in framesData)
            {
                maxSpriteSheetWidth = Math.Max(maxSpriteSheetWidth, frame.PixelSize.Width);
            }

            foreach (var frame in framesData)
            {
                frame.SheetPos = new Point();

                newLineWidth = lineWidth + frame.PixelSize.Width;

                if (newLineWidth > maxSpriteSheetWidth)
                {
                    // finish line
                    spriteSheetSize.Width = Math.Max(spriteSheetSize.Width, lineWidth);
                    spriteSheetSize.Height += lineHight;

                    // start new line
                    //lineWidth = 0
                    //lineHight = 0;
                    lineWidth = frame.PixelSize.Width;
                    lineHight = frame.PixelSize.Height;

                    // lay the frame on the new line
                    //frame.SheetPos.X = 0;
                    frame.SheetPos.Y = spriteSheetSize.Height;
                }
                else
                {
                    frame.SheetPos.X = lineWidth;
                    frame.SheetPos.Y = spriteSheetSize.Height;

                    // add to current line
                    lineWidth = newLineWidth;
                    lineHight = Math.Max(lineHight, frame.PixelSize.Height);
                }
            }

            // include last unfinished line
            spriteSheetSize.Width = Math.Max(spriteSheetSize.Width, lineWidth);
            spriteSheetSize.Height += lineHight;

            return spriteSheetSize;
        }

        private static AnimationChainListSave _DrawSpritesAndCreateAnimChainsList(
            FrameFileInfo[][] animGroups, SizeInt spriteSheetSize, string spriteSheetFileName, BlitBitmap spriteSheetBBmp)
        {
            spriteSheetFileName = spriteSheetFileName + ".png";

            AnimationChainListSave animList = new AnimationChainListSave
            {
                FileRelativeTextures = true,
                CoordinateType = FlatRedBall.Graphics.TextureCoordinateType.Pixel,
                FileName = spriteSheetFileName,
                TimeMeasurementUnit = FlatRedBall.TimeMeasurementUnit.Second
            };

            AnimationChainSave animChain;
            Bitmap frameSprite;

            foreach (var anim in animGroups)
            {
                animChain = new AnimationChainSave
                {
                    Name = anim[0].AnimName
                };

                animList.AnimationChains.Add(animChain);

                foreach (var frame in anim)
                {
                    // - Load image from file
                    using (var stream = frame.FileInfo.OpenRead())
                    {
                        frameSprite = (Bitmap)Image.FromStream(stream);

                        spriteSheetBBmp.Blit(frameSprite, frame.SheetPos.X, frame.SheetPos.Y);
                    }

                    animChain.Frames.Add(
                        new AnimationFrameSave
                        {
                            TextureName = spriteSheetFileName,
                            FrameLength = 0.1f,

                            LeftCoordinate = frame.SheetPos.X,
                            TopCoordinate = frame.SheetPos.Y,
                            RightCoordinate = frame.SheetPos.X + frame.PixelSize.Width,
                            BottomCoordinate = frame.SheetPos.Y + frame.PixelSize.Height
                        }
                    );
                }
            }

            return animList;
        }

        #endregion --- GenerateFromImgSequences END




        // --- General


    }
}
